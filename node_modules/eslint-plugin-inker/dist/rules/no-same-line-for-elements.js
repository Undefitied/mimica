"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const invokeIfFunction_1 = __importDefault(require("../utils/invokeIfFunction"));
function findSameLineNodes(nodes) {
    const problematicNodes = [];
    let prevNode = nodes[0];
    for (let i = 1; i < nodes.length; ++i) {
        const node = nodes[i];
        if (node.loc.start.line === prevNode.loc.end.line) {
            problematicNodes.push(node);
        }
        prevNode = node;
    }
    return problematicNodes;
}
exports.default = {
    meta: {
        deprecated: true,
        fixable: "whitespace",
    },
    create(context) {
        const handle = (options) => {
            var _a, _b;
            const { loc } = options.node;
            if (!loc || loc.start.line === loc.end.line) {
                return;
            }
            const children = (0, invokeIfFunction_1.default)(options.children);
            if (children.length < 2) {
                return;
            }
            const isFirstItemSameLine = ((_a = children[0].loc) === null || _a === void 0 ? void 0 : _a.start.line) === loc.start.line;
            // eslint-disable-next-line unicorn/prefer-at
            const isLastItemSameLine = ((_b = children[children.length - 1].loc) === null || _b === void 0 ? void 0 : _b.end.line) === loc.end.line;
            if (isFirstItemSameLine || isLastItemSameLine) {
                return;
            }
            const problematicNodes = findSameLineNodes(children);
            const { message } = options;
            for (const problematicNode of problematicNodes) {
                context.report({
                    node: problematicNode,
                    message,
                    fix(fixer) {
                        return fixer.insertTextBefore(problematicNode, "\n");
                    },
                });
            }
        };
        return {
            FunctionDeclaration(node) {
                handle({
                    node,
                    message: "Function parameters must be on separate lines",
                    children: node.params,
                });
            },
            CallExpression(node) {
                handle({
                    node,
                    message: "Function arguments must be on separate lines",
                    children: node.arguments,
                });
            },
            ArrayExpression(node) {
                handle({
                    node,
                    message: "Array elements must be on separate lines",
                    children: () => (0, lodash_1.compact)(node.elements),
                });
            },
            ArrayPattern(node) {
                handle({
                    node,
                    message: "Variables from array destructuring must be on separate lines",
                    children: () => (0, lodash_1.compact)(node.elements),
                });
            },
            ObjectExpression(node) {
                handle({
                    node,
                    message: "Object properties must be on separate lines",
                    children: node.properties,
                });
            },
            ObjectPattern(node) {
                handle({
                    node,
                    message: "Variables from object destructuring must be on separate lines",
                    children: node.properties,
                });
            },
        };
    },
};
