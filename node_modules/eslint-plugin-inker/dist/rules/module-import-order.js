"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const isNonDecreasing_1 = __importDefault(require("../utils/isNonDecreasing"));
const WILDCARD_OTHER = "*";
exports.default = {
    meta: {
        schema: [
            {
                type: "array",
                items: {
                    type: "object",
                    properties: {
                        name: {
                            type: "string",
                        },
                        before: {
                            type: "array",
                            items: {
                                type: "string",
                            },
                        },
                        after: {
                            type: "array",
                            items: {
                                type: "string",
                            },
                        },
                    },
                    required: ["name"],
                },
            },
        ],
        fixable: "code",
    },
    create(context) {
        var _a;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const options = (_a = context.options[0]) !== null && _a !== void 0 ? _a : [];
        const optionsEntries = options.map(item => {
            const { name, before = [], after = [] } = item;
            const afterOffset = Number.MAX_SAFE_INTEGER - after.length;
            const entries = [
                ...Object.entries(before).map(([k, v]) => [v, +k]),
                [WILDCARD_OTHER, before.length],
                ...Object.entries(after).map(([k, v]) => [v, +k + afterOffset]),
            ];
            return [name, Object.fromEntries(entries)];
        });
        const optionsMap = Object.fromEntries(optionsEntries);
        return {
            ImportDeclaration(node) {
                const importSource = node.source.value;
                const o = optionsMap[importSource];
                if (!o) {
                    return;
                }
                const { specifiers } = node;
                if (specifiers.length < 2) {
                    return;
                }
                const iteratee = (item) => { var _a; return (_a = o[item.imported.name]) !== null && _a !== void 0 ? _a : o[WILDCARD_OTHER]; };
                const importedMembers = specifiers.filter(item => item.type === "ImportSpecifier");
                if ((0, isNonDecreasing_1.default)(importedMembers, iteratee)) {
                    return;
                }
                context.report({
                    node,
                    message: `Invalid import order for "${importSource}".`,
                    fix(fixer) {
                        const { sourceCode } = context;
                        const orderedImports = (0, lodash_1.orderBy)(importedMembers, iteratee).map(item => sourceCode.getText(item));
                        return importedMembers.map((item, i) => fixer.replaceText(item, orderedImports[i]));
                    },
                });
            },
        };
    },
};
