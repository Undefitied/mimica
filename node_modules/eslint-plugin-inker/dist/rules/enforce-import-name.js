"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const minimatch_1 = require("minimatch");
const lodash_1 = require("lodash");
const mergeMaps_1 = __importDefault(require("../utils/mergeMaps"));
const importNamesSchema = {
    type: "array",
    items: {
        type: "object",
        properties: {
            imported: {
                type: "string",
            },
            local: {
                type: "string",
            },
        },
        required: ["imported", "local"],
    },
};
exports.default = {
    meta: {
        schema: [
            {
                type: "object",
                properties: {
                    paths: {
                        type: "array",
                        items: {
                            type: "object",
                            oneOf: [
                                {
                                    properties: {
                                        name: {
                                            type: "string",
                                        },
                                        importNames: importNamesSchema,
                                    },
                                    required: ["name", "importNames"],
                                },
                                {
                                    properties: {
                                        pattern: {
                                            oneOf: [
                                                {
                                                    type: "string",
                                                },
                                                {
                                                    type: "array",
                                                    items: {
                                                        type: "string",
                                                    },
                                                },
                                            ],
                                        },
                                        importNames: importNamesSchema,
                                    },
                                    required: ["pattern", "importNames"],
                                },
                            ],
                        },
                    },
                },
            },
        ],
        hasSuggestions: true,
    },
    create(context) {
        var _a;
        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment
        const options = (_a = context.options[0]) !== null && _a !== void 0 ? _a : {};
        const pathsTransformed = options.paths.map(item => ({
            ...item,
            localByImported: new Map(item.importNames.map(o => [o.imported, o.local])),
            patterns: "pattern" in item ? (0, lodash_1.castArray)(item.pattern) : undefined,
        }));
        const findPaths = (name) => pathsTransformed.filter(item => {
            if ("name" in item) {
                return item.name === name;
            }
            const { patterns } = item;
            return patterns.some(pattern => (0, minimatch_1.minimatch)(name, pattern));
        });
        return {
            ImportDeclaration(node) {
                const { source, specifiers } = node;
                const foundPaths = findPaths(source.value);
                if (foundPaths.length === 0) {
                    return;
                }
                const localByImported = new Map(foundPaths.flatMap(item => [...item.localByImported]));
                const issuesWithGaps = specifiers.map((s) => {
                    if (s.type === "ImportSpecifier") {
                        const suggestedName = localByImported.get(s.imported.name);
                        return (!!suggestedName &&
                            suggestedName !== s.local.name && {
                            node: s.local,
                            message: `Local name should be "${suggestedName}"`,
                            suggest: [
                                {
                                    desc: `Rename to '${suggestedName}'`,
                                    fix(fixer) {
                                        var _a, _b;
                                        const references = (_b = (_a = context.getDeclaredVariables(s)[0]) === null || _a === void 0 ? void 0 : _a.references) !== null && _b !== void 0 ? _b : [];
                                        return [
                                            fixer.replaceText(s, `${s.imported.name} as ${suggestedName}`),
                                            ...references.map(ref => fixer.replaceText(ref.identifier, suggestedName)),
                                        ];
                                    },
                                },
                            ],
                        });
                    }
                    if (s.type === "ImportDefaultSpecifier") {
                        const suggestedName = localByImported.get("default");
                        return (!!suggestedName &&
                            suggestedName !== s.local.name && {
                            node: s.local,
                            message: `Local name should be "${suggestedName}"`,
                            suggest: [
                                {
                                    desc: `Rename to '${suggestedName}'`,
                                    fix(fixer) {
                                        var _a, _b;
                                        const references = (_b = (_a = context.getDeclaredVariables(s)[0]) === null || _a === void 0 ? void 0 : _a.references) !== null && _b !== void 0 ? _b : [];
                                        return [
                                            s.local,
                                            ...references.map(ref => ref.identifier),
                                        ].map(identifier => fixer.replaceText(identifier, suggestedName));
                                    },
                                },
                            ],
                        });
                    }
                    if (s.type === "ImportNamespaceSpecifier") {
                        const suggestedName = localByImported.get("namespace");
                        return (!!suggestedName &&
                            suggestedName !== s.local.name && {
                            node: s.local,
                            message: `Local name should be "${suggestedName}"`,
                            suggest: [
                                {
                                    desc: `Rename to '${suggestedName}'`,
                                    fix(fixer) {
                                        var _a, _b;
                                        const references = (_b = (_a = context.getDeclaredVariables(s)[0]) === null || _a === void 0 ? void 0 : _a.references) !== null && _b !== void 0 ? _b : [];
                                        return [
                                            s.local,
                                            ...references.map(ref => ref.identifier),
                                        ].map(identifier => fixer.replaceText(identifier, suggestedName));
                                    },
                                },
                            ],
                        });
                    }
                    return false;
                });
                const issues = (0, lodash_1.compact)(issuesWithGaps);
                for (const issue of issues) {
                    context.report(issue);
                }
            },
            VariableDeclaration(node) {
                const declaration = node.declarations[0];
                const { id, init } = declaration;
                const isRequire = init &&
                    init.type === "CallExpression" &&
                    init.callee.type === "Identifier" &&
                    init.callee.name === "require";
                if (!isRequire) {
                    return;
                }
                const source = init.arguments[0];
                const foundPaths = findPaths(source.value);
                if (foundPaths.length === 0) {
                    return;
                }
                const localByImported = (0, mergeMaps_1.default)(foundPaths.map(item => item.localByImported));
                const issuesWithGaps = (() => {
                    var _a;
                    if (id.type === "ObjectPattern") {
                        return id.properties.map(prop => {
                            const { type: propType } = prop;
                            if (propType !== "Property") {
                                return false;
                            }
                            const { key, value } = prop;
                            if (key.type !== "Identifier" || value.type !== "Identifier") {
                                return false;
                            }
                            const suggestedName = localByImported.get(key.name);
                            return (!!suggestedName &&
                                suggestedName !== value.name && {
                                node: value,
                                message: `Local name should be "${suggestedName}"`,
                            });
                        });
                    }
                    if (id.type === "Identifier") {
                        const suggestedName = (_a = localByImported.get("default")) !== null && _a !== void 0 ? _a : localByImported.get("namespace");
                        return [
                            !!suggestedName &&
                                suggestedName !== id.name && {
                                node: id,
                                message: `Local name should be "${suggestedName}"`,
                            },
                        ];
                    }
                    return [];
                })();
                const issues = (0, lodash_1.compact)(issuesWithGaps);
                for (const issue of issues) {
                    context.report(issue);
                }
            },
        };
    },
};
