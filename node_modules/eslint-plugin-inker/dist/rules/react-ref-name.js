"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const refCreationFuncNames = new Set(["createRef", "useRef"]);
const isIdValidName = (name) => name === "ref" || name.endsWith("Ref");
exports.default = {
    meta: {
        hasSuggestions: true,
    },
    create(context) {
        const variableDeclaratorStrategy = (node) => {
            const { id } = node;
            if (id.type !== "Identifier") {
                return;
            }
            if (isIdValidName(id.name)) {
                return;
            }
            const suggestedName = `${id.name}Ref`;
            const scope = context.getScope();
            const isNameTaken = scope.variables.some(variable => variable.name === suggestedName);
            const suggest = isNameTaken
                ? undefined
                : [
                    {
                        desc: `Rename variable to '${suggestedName}'`,
                        fix(fixer) {
                            var _a, _b;
                            const references = (_b = (_a = context.getDeclaredVariables(node)[0]) === null || _a === void 0 ? void 0 : _a.references) !== null && _b !== void 0 ? _b : [];
                            return references.map(ref => fixer.replaceText(ref.identifier, suggestedName));
                        },
                    },
                ];
            context.report({
                node: id,
                message: 'Variable name should be "ref" or end with "Ref".',
                suggest,
            });
        };
        const propertyDefinitionStrategy = (node) => {
            const { key } = node;
            if (key.type !== "Identifier") {
                return;
            }
            if (isIdValidName(key.name)) {
                return;
            }
            context.report({
                node: key,
                message: 'Property name should be "ref" or end with "Ref".',
            });
        };
        return {
            CallExpression(node) {
                if (node.type !== "CallExpression") {
                    return;
                }
                const { callee } = node;
                if (callee.type !== "Identifier" ||
                    !refCreationFuncNames.has(callee.name)) {
                    return;
                }
                const { parent } = node;
                switch (parent.type) {
                    case "VariableDeclarator": {
                        variableDeclaratorStrategy(parent);
                        break;
                    }
                    case "PropertyDefinition": {
                        propertyDefinitionStrategy(parent);
                        break;
                    }
                    default: {
                        break;
                    }
                }
            },
        };
    },
};
